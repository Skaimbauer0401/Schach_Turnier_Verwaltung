<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>♟️</text></svg>">
    <title>Chess Match Matrix</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            height: calc(100vh - 20px);
            overflow: hidden;
        }
        h1 {
            color: #333;
            text-align: center;
            margin: 5px 0;
        }
        h2#tournament-title {
            color: #2196F3;
            text-align: center;
            margin: 5px 0;
            font-size: 1.2em;
        }
        .description {
            text-align: center;
            margin-bottom: 10px;
            padding: 5px;
            background-color: #e9f7ef;
            border-radius: 5px;
        }
        .controls {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .player-input {
            display: flex;
            align-items: center;
        }
        input[type="text"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 10px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        .matrix-container {
            overflow: auto;
            flex: 1;
            min-height: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 4px;
            text-align: center;
        }
        th {
            background-color: #4CAF50;
            color: white;
            position: sticky;
            top: 0;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .player-name {
            font-weight: bold;
            background-color: #4CAF50;
            color: white;
        }
        .match-cell {
            position: relative;
        }
        .match-cell.disabled {
            background-color: #ddd;
        }
        .result-selector {
            display: none;
            position: absolute;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            z-index: 10;
            width: 120px;
            overflow: hidden;
        }
        .result-option {
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: center;
            font-weight: bold;
        }
        .result-option:nth-child(1) {
            background-color: #d4edda;
            color: #155724;
        }
        .result-option:nth-child(2) {
            background-color: #f8d7da;
            color: #721c24;
        }
        .result-option:nth-child(3) {
            background-color: #fff3cd;
            color: #856404;
        }
        .result-option:nth-child(4) {
            background-color: #e2e3e5;
            color: #383d41;
        }
        .result-option:hover {
            filter: brightness(0.95);
        }
        .win {
            color: green;
            font-weight: bold;
        }
        .loss {
            color: red;
            font-weight: bold;
        }
        .draw {
            color: orange;
            font-weight: bold;
        }
        .legend {
            margin-top: 10px;
            margin-bottom: 10px;
            padding: 5px;
            background-color: #f1f1f1;
            border-radius: 5px;
            font-size: 0.9em;
        }
        .legend-item {
            margin: 2px 0;
        }
        .legend-content {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Chess Match Matrix</h1>
        <h2 id="tournament-title">Tournament: </h2>

        <div class="description">
            This matrix shows match results between players. Click on a cell to record a win, loss, or draw.
        </div>

        <div class="controls">
        </div>

        <div class="legend">
            <div class="legend-content" id="legend-content">
                <div class="legend-item"><span class="win">← W</span> - Win (Row player won against Column player)</div>
                <div class="legend-item"><span class="loss">← L</span> - Loss (Row player lost to Column player)</div>
                <div class="legend-item"><span class="draw">← D</span> - Draw (Row player drew with Column player)</div>
                <div class="legend-item">Empty - No result recorded</div>
            </div>
        </div>

        <div class="matrix-container" style="padding-bottom: 20px;">
            <table id="match-matrix">
                <tr>
                    <th>Players</th>
                </tr>
            </table>
        </div>

        <div class="button-container" style="margin-top: 20px; margin-bottom: 20px; display: flex; justify-content: center; gap: 10px;">
            <button onclick="goBack()" style="background-color: #2196F3;">Back to Previous Page</button>
            <button onclick="resetMatrix()" style="background-color: #FF9800;">Reset Matrix</button>
            <button onclick="saveMatches()">Save Matches</button>
        </div>
    </div>

    <script>
        // Global variables
        let players = [];
        let matchResults = {};
        let tournamentId = '';
        let tournamentName = '';

        // Function to get URL parameters
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            var results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        // Function to go back to previous page
        function goBack() {
            window.history.back();
        }

        // Function to reset the matrix
        function resetMatrix() {
            if (confirm('Are you sure you want to reset all match results?')) {
                matchResults = {};
                updateMatrix();
            }
        }

        // Function to fetch players for a tournament
        function fetchPlayersFromTournament(tournamentId) {
            fetch(`http://localhost:8080/persons/person/getPersonByTournament/${tournamentId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Fetched players:', data);
                    players = data;

                    // Create a map of player IDs to names for later use
                    const playerIdToName = {};
                    players.forEach(player => {
                        playerIdToName[player.id] = player.username;
                    });

                    // Build the matrix with the players
                    buildMatrix(players);

                    // Fetch match results after building the matrix
                    fetchMatchResults(tournamentId, playerIdToName);
                })
                .catch(error => {
                    console.error('Error fetching players:', error);
                    alert('Failed to load players. Please try again later.');
                });
        }

        // Function to build the matrix table
        function buildMatrix(players) {
            const table = document.getElementById('match-matrix');

            // Clear existing table content
            table.innerHTML = '';

            // Create header row with player names
            const headerRow = document.createElement('tr');
            const cornerCell = document.createElement('th');
            cornerCell.textContent = 'Players';
            headerRow.appendChild(cornerCell);

            players.forEach(player => {
                const th = document.createElement('th');
                th.textContent = player.username + ' (' + player.id + ')';
                headerRow.appendChild(th);
            });

            table.appendChild(headerRow);

            // Create rows for each player
            players.forEach((rowPlayer, rowIndex) => {
                const row = document.createElement('tr');

                // Add player name as first cell in the row
                const nameCell = document.createElement('td');
                nameCell.textContent = rowPlayer.username + ' (' + rowPlayer.id + ')';
                nameCell.className = 'player-name';
                row.appendChild(nameCell);

                // Add match cells for each player
                players.forEach((colPlayer, colIndex) => {
                    const cell = document.createElement('td');

                    if (rowIndex === colIndex) {
                        // Diagonal cells (player vs themselves) are disabled
                        cell.className = 'match-cell disabled';
                        cell.textContent = 'X';
                    } else {
                        cell.className = 'match-cell';
                        cell.dataset.row = rowPlayer.id;
                        cell.dataset.col = colPlayer.id;
                        cell.dataset.rowName = rowPlayer.username;
                        cell.dataset.colName = colPlayer.username;

                        // Add click event to show result selector
                        cell.addEventListener('click', function() {
                            showResultSelector(this);
                        });
                    }

                    row.appendChild(cell);
                });

                table.appendChild(row);
            });
        }

        // Function to show result selector
        function showResultSelector(cell) {
            // Remove any existing result selectors
            const existingSelectors = document.querySelectorAll('.result-selector');
            existingSelectors.forEach(selector => selector.remove());

            // Create result selector
            const selector = document.createElement('div');
            selector.className = 'result-selector';

            // Add options
            const options = [
                { text: 'Win', value: 'W', class: 'win' },
                { text: 'Loss', value: 'L', class: 'loss' },
                { text: 'Draw', value: 'D', class: 'draw' },
                { text: 'Clear', value: '', class: '' }
            ];

            options.forEach(option => {
                const optionElement = document.createElement('div');
                optionElement.className = 'result-option';
                optionElement.textContent = option.text;

                optionElement.addEventListener('click', function() {
                    setMatchResult(cell, option.value, option.class);
                    selector.remove();
                });

                selector.appendChild(optionElement);
            });

            // Position and show the selector
            cell.appendChild(selector);
            selector.style.display = 'block';

            // Close selector when clicking outside
            document.addEventListener('click', function closeSelector(e) {
                if (!selector.contains(e.target) && e.target !== cell) {
                    selector.remove();
                    document.removeEventListener('click', closeSelector);
                }
            });
        }

        // Function to set match result
        function setMatchResult(cell, result, resultClass) {
            const rowPlayerId = cell.dataset.row;
            const colPlayerId = cell.dataset.col;
            const rowPlayerName = cell.dataset.rowName;
            const colPlayerName = cell.dataset.colName;

            // Store the result for the clicked cell
            if (result) {
                matchResults[`${rowPlayerId}-${colPlayerId}`] = result;

                // Calculate and store the inverse result for the opposite cell
                let inverseResult = '';
                let inverseClass = '';

                if (result === 'W') {
                    inverseResult = 'L'; // If player1 won, player2 lost
                    inverseClass = 'loss';
                } else if (result === 'L') {
                    inverseResult = 'W'; // If player1 lost, player2 won
                    inverseClass = 'win';
                } else if (result === 'D') {
                    inverseResult = 'D'; // If it was a draw, it's still a draw
                    inverseClass = 'draw';
                }

                // Store the inverse result
                if (inverseResult) {
                    matchResults[`${colPlayerId}-${rowPlayerId}`] = inverseResult;

                    // Find and update the inverse cell
                    const inverseCell = document.querySelector(`.match-cell[data-row="${colPlayerId}"][data-col="${rowPlayerId}"]`);
                    if (inverseCell) {
                        updateCellDisplay(inverseCell, inverseResult, inverseClass);
                    }
                }
            } else {
                // If result is empty (Clear option), delete both entries
                delete matchResults[`${rowPlayerId}-${colPlayerId}`];
                delete matchResults[`${colPlayerId}-${rowPlayerId}`];

                // Find and clear the inverse cell
                const inverseCell = document.querySelector(`.match-cell[data-row="${colPlayerId}"][data-col="${rowPlayerId}"]`);
                if (inverseCell) {
                    updateCellDisplay(inverseCell, '', '');
                }
            }

            // Update the clicked cell display
            updateCellDisplay(cell, result, resultClass);
        }

        // Function to update cell display
        function updateCellDisplay(cell, result, resultClass) {
            // Clear existing content
            cell.textContent = '';
            cell.classList.remove('win', 'loss', 'draw');

            if (result) {
                // Add the result text with the appropriate class
                cell.textContent = `← ${result}`;
                cell.classList.add(resultClass);
            }
        }

        // Function to update the entire matrix with current results
        function updateMatrix() {
            // Clear all cells first
            const cells = document.querySelectorAll('.match-cell:not(.disabled)');
            cells.forEach(cell => {
                cell.textContent = '';
                cell.classList.remove('win', 'loss', 'draw');
            });

            // Update cells with current match results
            for (const [key, result] of Object.entries(matchResults)) {
                const [rowPlayerId, colPlayerId] = key.split('-');
                const cell = document.querySelector(`.match-cell[data-row="${rowPlayerId}"][data-col="${colPlayerId}"]`);

                if (cell) {
                    let resultClass = '';
                    if (result === 'W') resultClass = 'win';
                    else if (result === 'L') resultClass = 'loss';
                    else if (result === 'D') resultClass = 'draw';

                    updateCellDisplay(cell, result, resultClass);
                }
            }
        }

        // Function to fetch match results from the tournament API
        function fetchMatchResults(tournamentId, playerIdToName) {
            fetch(`http://localhost:8080/tournaments/getMatches/${tournamentId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    // Clear existing match results
                    matchResults = {};

                    // Process each match result
                    for (const [key, result] of Object.entries(data)) {
                        // Parse the key to get player IDs (format: "player1Id-player2Id")
                        const [player1Id, player2Id] = key.split('-');

                        // Store the original match result
                        matchResults[key] = result;

                        // Store the inverse match result for the opposite cell
                        let inverseResult = '';
                        if (result === 'W') {
                            inverseResult = 'L'; // If player1 won, player2 lost
                        } else if (result === 'L') {
                            inverseResult = 'W'; // If player1 lost, player2 won
                        } else if (result === 'D') {
                            inverseResult = 'D'; // If it was a draw, it's still a draw
                        }

                        // Only add the inverse result if we have a valid result
                        if (inverseResult) {
                            matchResults[`${player2Id}-${player1Id}`] = inverseResult;
                        }
                    }

                    // Update the matrix with the match results
                    updateMatrix();
                })
                .catch(error => {
                    console.error('Error fetching match results:', error);
                    // Don't show an alert for this error, as it's not critical
                    console.log('Failed to load match results. The matrix will be empty.');
                });
        }

        // Function to save matches
        function saveMatches() {
            fetch(`http://localhost:8080/tournaments/addMatches/${tournamentId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(matchResults)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.text();
            })
            .then(data => {
                alert('Match results saved successfully!');
                console.log('Save response:', data);
            })
            .catch(error => {
                console.error('Error saving match results:', error);
                alert('Failed to save match results. Please try again later.');
            });
        }

        // Initialize the page when loaded
        window.onload = function() {
            // Get tournament information from URL parameters
            tournamentId = getUrlParameter('tournamentId');
            tournamentName = getUrlParameter('tournamentName');

            // Display tournament name
            document.getElementById('tournament-title').textContent = 'Tournament: ' + tournamentName;

            // Fetch players for the tournament
            if (tournamentId) {
                fetchPlayersFromTournament(tournamentId);
            } else {
                alert('No tournament ID provided. Please go back and select a tournament.');
            }
        };
    </script>
</body>
</html>
